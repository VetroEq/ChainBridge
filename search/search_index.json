{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udf09 Overview \u00b6 Relevant repos \u00b6 ChainBridge \u00b6 chainbridge A Modular Multi-Directional Blockchain Bridge to interact with Multiple Networks; Ethereum, Ethereum Classic, Substrate, Cosmos-SDK based chains. Ethereum (Solidity) \u00b6 chainbridge-solidity The Solidity contracts required for chainbridge. Includes deployment and interaction CLI. The bindings for the contracts live in bindings/ . To update the bindings modify scripts/setup-contracts.sh and then run make clean && make setup-contracts Substrate \u00b6 chainbridge-substrate A substrate pallet that can be integrated into a chain, as well as an example pallet to demonstrate chain integration. Notion \u00b6 To learn more about ChainBridge check out the Notion page.","title":"Overview"},{"location":"#overview","text":"","title":"\ud83c\udf09  Overview "},{"location":"#relevant-repos","text":"","title":"Relevant repos"},{"location":"#chainbridge","text":"chainbridge A Modular Multi-Directional Blockchain Bridge to interact with Multiple Networks; Ethereum, Ethereum Classic, Substrate, Cosmos-SDK based chains.","title":"ChainBridge"},{"location":"#ethereum-solidity","text":"chainbridge-solidity The Solidity contracts required for chainbridge. Includes deployment and interaction CLI. The bindings for the contracts live in bindings/ . To update the bindings modify scripts/setup-contracts.sh and then run make clean && make setup-contracts","title":"Ethereum (Solidity)"},{"location":"#substrate","text":"chainbridge-substrate A substrate pallet that can be integrated into a chain, as well as an example pallet to demonstrate chain integration.","title":"Substrate"},{"location":"#notion","text":"To learn more about ChainBridge check out the Notion page.","title":"Notion"},{"location":"configuration/","text":"Configuration \u00b6 Note: TOML configs have been deprecated in favour of JSON A chain configurations take this form: { \"name\": \"eth\", // Human-readable name \"type\": \"ethereum\", // Chain type (eg. \"ethereum\" or \"substrate\") \"id\": \"0\", // Chain ID \"endpoint\": \"ws://<host>:<port>\", // Node endpoint \"from\": \"0xff93...\", // On-chain address of relayer \"opts\": {}, // Chain-specific configuration options (see below) } See config.json.example for an example configuration. Ethereum Options \u00b6 Ethereum chains support the following additional options: { \"bridge\": \"0x12345...\" // Address of the bridge contract (required) \"erc20Handler\": \"0x1234...\" // Address of erc20 handler (required) \"erc721Handler\": \"0x1234...\" // Address of erc721 handler (required) \"genericHandler\": \"0x1234...\" // Address of generic handler (required) \"maxGasPrice\": \"0x1234\" // Gas price for transactions (default: 20000000000) \"gasLimit\": \"0x1234\" // Gas limit for transactions (default: 6721975) \"http\": \"true\" // Whether the chain connection is ws or http (default: false) \"startBlock\": \"1234\" // The block to start processing events from (default: 0) } Substrate Options \u00b6 Substrate supports the following additonal options: { \"startBlock\": \"1234\" // The block to start processing events from (default: 0) } Blockstore \u00b6 The blockstore is used to record the last block the relayer processed, so it can pick up where it left off. If a startBlock option is provided (see Configuration ), then the greater of startBlock and the latest block in the blockstore is used at startup. To disable loading from the blockstore specify the --fresh flag. A custom path for the blockstore can be provided with --blockstore <path> . For development, the --latest flag can be used to start from the current block and override any other configuration. Keystore \u00b6 ChainBridge requires keys to sign and submit transactions, and to identify each bridge node on chain. To use secure keys, see chainbridge accounts --help . The keystore password can be supplied with the KEYSTORE_PASSWORD environment variable. To import external ethereum keys, such as those generated with geth, use chainbridge accounts import --ethereum /path/to/key . To import private keys as keystores, use chainbridge account import --privateKey key . For testing purposes, chainbridge provides 5 test keys. The can be used with --testkey <name> , where name is one of Alice , Bob , Charlie , Dave , or Eve .","title":"Configuration"},{"location":"configuration/#configuration","text":"Note: TOML configs have been deprecated in favour of JSON A chain configurations take this form: { \"name\": \"eth\", // Human-readable name \"type\": \"ethereum\", // Chain type (eg. \"ethereum\" or \"substrate\") \"id\": \"0\", // Chain ID \"endpoint\": \"ws://<host>:<port>\", // Node endpoint \"from\": \"0xff93...\", // On-chain address of relayer \"opts\": {}, // Chain-specific configuration options (see below) } See config.json.example for an example configuration.","title":"Configuration"},{"location":"configuration/#ethereum-options","text":"Ethereum chains support the following additional options: { \"bridge\": \"0x12345...\" // Address of the bridge contract (required) \"erc20Handler\": \"0x1234...\" // Address of erc20 handler (required) \"erc721Handler\": \"0x1234...\" // Address of erc721 handler (required) \"genericHandler\": \"0x1234...\" // Address of generic handler (required) \"maxGasPrice\": \"0x1234\" // Gas price for transactions (default: 20000000000) \"gasLimit\": \"0x1234\" // Gas limit for transactions (default: 6721975) \"http\": \"true\" // Whether the chain connection is ws or http (default: false) \"startBlock\": \"1234\" // The block to start processing events from (default: 0) }","title":"Ethereum Options"},{"location":"configuration/#substrate-options","text":"Substrate supports the following additonal options: { \"startBlock\": \"1234\" // The block to start processing events from (default: 0) }","title":"Substrate Options"},{"location":"configuration/#blockstore","text":"The blockstore is used to record the last block the relayer processed, so it can pick up where it left off. If a startBlock option is provided (see Configuration ), then the greater of startBlock and the latest block in the blockstore is used at startup. To disable loading from the blockstore specify the --fresh flag. A custom path for the blockstore can be provided with --blockstore <path> . For development, the --latest flag can be used to start from the current block and override any other configuration.","title":"Blockstore"},{"location":"configuration/#keystore","text":"ChainBridge requires keys to sign and submit transactions, and to identify each bridge node on chain. To use secure keys, see chainbridge accounts --help . The keystore password can be supplied with the KEYSTORE_PASSWORD environment variable. To import external ethereum keys, such as those generated with geth, use chainbridge accounts import --ethereum /path/to/key . To import private keys as keystores, use chainbridge account import --privateKey key . For testing purposes, chainbridge provides 5 test keys. The can be used with --testkey <name> , where name is one of Alice , Bob , Charlie , Dave , or Eve .","title":"Keystore"},{"location":"installation/","text":"Installation \u00b6 Docker \u00b6 The official ChainBridge Docker image To build the Docker image use docker build -t chainsafe/chainbridge . To start ChainBridge docker run -v ./config.toml:/config.toml chainsafe/chainbridge Dependencies \u00b6 Subkey : Used for substrate key management. Only required if connecting to a substrate chain. make install-subkey Building from Source \u00b6 make build : Builds chainbridge in ./build . or make install : Uses go install to add chainbridge to your GOBIN.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#docker","text":"The official ChainBridge Docker image To build the Docker image use docker build -t chainsafe/chainbridge . To start ChainBridge docker run -v ./config.toml:/config.toml chainsafe/chainbridge","title":"Docker"},{"location":"installation/#dependencies","text":"Subkey : Used for substrate key management. Only required if connecting to a substrate chain. make install-subkey","title":"Dependencies"},{"location":"installation/#building-from-source","text":"make build : Builds chainbridge in ./build . or make install : Uses go install to add chainbridge to your GOBIN.","title":"Building from Source"},{"location":"local/","text":"Running Locally \u00b6 Prerequisites \u00b6 Docker, docker-compose chainbridge v1.0.0 binary (see README ) Polkadot JS Portal ( https://portal.chain.centrifuge.io ) Type definitions can be found here: https://gist.github.com/ansermino/0280b30594a9bc653ae288ccca46dc55 cb-sol-cli (see README ) Starting Local Chains \u00b6 The easiest way to get started is to use the docker-compose file found here: https://gist.github.com/ansermino/f1571bb354d2007b26dce53d52dbca75 . This will start a geth instance and an instance of chainbridge-substrate-chain: docker-compose -f ./docker-compose-geth-substrate.yml up -V (Use -V to always start with new chains. These instructions depend on deterministic ethereum addresses, which are used as defaults implicitly by some of these commands. Avoid re-deploying the contracts without restarting both chains, or ensure to specify all the required parameters.) On-Chain Setup (Ethereum) \u00b6 Deploy Contracts \u00b6 You can deploy the contracts to the geth chain like this: cb-sol-cli deploy --all --relayerThreshold 1 You should see an output such as this: ================================================================ Url: http://localhost:8545 Deployer: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Gas Limit: 8000000 Gas Price: 20000000 Deploy Cost: 0 .0 Options ======= Chain Id: 0 Threshold: 2 Relayers: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca,0x8e0a907331554AF72563Bd8D43051C2E64Be5d35,0x24962717f8fA5BA3b931bACaF9ac03924EB475a0,0x148FfB2074A9e59eD58142822b3eB3fcBffb0cd7,0x4CEEf6139f00F9F4535Ad19640Ff7A0137708485 Bridge Fee: 0 Expiry: 100 Contract Addresses ================================================================ Bridge: 0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B ---------------------------------------------------------------- Erc20 Handler: 0x3167776db165D8eA0f51790CA2bbf44Db5105ADF ---------------------------------------------------------------- Erc721 Handler: 0x3f709398808af36ADBA86ACC617FeB7F5B7B193E ---------------------------------------------------------------- Generic Handler: 0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07 ---------------------------------------------------------------- Erc20: 0x21605f71845f372A9ed84253d2D024B7B10999f4 ---------------------------------------------------------------- Erc721: 0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31 ---------------------------------------------------------------- Centrifuge Asset: 0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4 ================================================================ Register Resources \u00b6 # Register fungible resource ID with erc20 contract cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" --targetContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" # Register non-fungible resource ID with erc721 contract cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --targetContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" # Register generic resource ID cb-sol-cli bridge register-generic-resource --resourceId \"0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01\" --targetContract \"0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4\" --handler \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" --hash --deposit \"\" --execute \"store(bytes32)\" Specify Token Semantics \u00b6 To allow for a variety of use cases, the ethereum contracts support both the transfer and the mint/burn ERC methods. To simplify these examples we should use mint/burn : # Register the erc20 contract as mintable/burnable cb-sol-cli bridge set-burn --tokenContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" # Register the associated handler as a minter cb-sol-cli erc20 add-minter --minter \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" # Register the erc721 contract as mintable/burnable cb-sol-cli bridge set-burn --tokenContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" # Add the handler as a minter cb-sol-cli erc721 add-minter --minter \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" On-Chain Setup (Substrate) \u00b6 Add Relayer \u00b6 We need to register the account of the relayer on substrate (cb-sol-cli deploys contracts with the 5 test keys preloaded). Select the Sudo tab in the PolkadotJS UI. Choose the addRelayer method of chainBridge , and select Alice as the relayer. Register Resources \u00b6 Select the Sudo tab and call chainBridge.setResourceId for each of the transfer types you wish to use: Fungible (Native asset): Id: 0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00 Method: 0x4578616d706c652e7472616e73666572 (utf-8 encoding of \"Example.transfer\") NonFungible(ERC721): Id: 0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501 Method: 0x4578616d706c652e6d696e745f657263373231 (utf-8 encoding of \"Example.mint_erc721\") Generic (Hash Transfer): Id: 0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01 Method: 0x4578616d706c652e72656d61726b (utf-8 encoding of \"Example.remark\") Whitelist Chains \u00b6 Using the Sudo tab, call chainBridge.whitelistChain , specifying 0 for out ethereum chain ID. Running A Relayer \u00b6 Here is an example config file for a single relayer using the contracts we deployed. { \"chains\" : [ { \"name\" : \"eth\" , \"type\" : \"ethereum\" , \"id\" : \"0\" , \"endpoint\" : \"ws://localhost:8545\" , \"from\" : \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\" , \"opts\" : { \"bridge\" : \"0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B\" , \"erc20Handler\" : \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" , \"erc721Handler\" : \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" , \"genericHandler\" : \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" , \"gasLimit\" : \"1000000\" , \"maxGasPrice\" : \"20000000\" } }, { \"name\" : \"sub\" , \"type\" : \"substrate\" , \"id\" : \"1\" , \"endpoint\" : \"ws://localhost:9944\" , \"from\" : \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\" , \"opts\" : {} } ] } You can then start a relayer using the default \"Alice\" key: chainbridge --config config.json --testkey alice --latest Fungible Transfers \u00b6 Substrate Native Token \u21d2 ERC 20 \u00b6 In the substrate UI select the Extrinsics tab, and call example.transferNative with these parameters: Amount: 1000 (select Pico for units) Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Dest Id: 0 You can query the recipients balance on ethereum with this: cb-sol-cli erc20 balance --address \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\" ERC20 \u21d2 Substrate Native Token \u00b6 If necessary, you can mint some tokens: cb-sol-cli erc20 mint --amount 1000 Before initiating the transfer we have to approve the bridge to take ownership of the tokens: cb-sol-cli erc20 approve --amount 1000 --recipient \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" To initiate a transfer on the ethereum chain use this command (Note: there will be a 10 block delay before the relayer will process the transfer): cb-sol-cli erc20 deposit --amount 1000 --dest 1 --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\" --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" Non-Fungible Transfers \u00b6 Substrate NFT \u21d2 ERC721 \u00b6 First, you'll probably need to mint a token. Select the Sudo tab and call erc721.mint with parameters such as these: Owner: Alice TokenId: 1 Metadata: \"\" Now the owner of the token can initiate a transfer by calling example.transferErc721 : Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca TokenId: 1 DestId: 0 You can query ownership of tokens on ethereum with this: cb-sol-cli erc721 owner --id 0x1 ERC721 \u21d2 Substrate NFT \u00b6 If necessary, you can mint an erc721 token like this: cb-sol-cli erc721 mint --id 0x99 Before initiating the transfer, we must approve the bridge to take ownership of the tokens: cb-sol-cli erc721 approve --id 0x99 --recipient \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" Now we can initiate the transfer: cb-sol-cli erc721 deposit --id 0x99 --dest 1 --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\" Generic Data Transfer \u00b6 To demonstrate a possible use of the generic data transfer, we have a hash registry on ethereum. We also have a method on the example substrate chain to emit a hash inside an event, which we can trigger from ethereum. Generic Data Substrate \u21d2 Eth \u00b6 For this example we will transfer a 32 byte hash to a registry on ethereum. Using the Extrinsics tab, call example.transferHash : Hash: 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730 Dest ID: 0 You can verify the transfer with this command: cb-sol-cli cent getHash --hash 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730","title":"Running Locally"},{"location":"local/#running-locally","text":"","title":"Running Locally"},{"location":"local/#prerequisites","text":"Docker, docker-compose chainbridge v1.0.0 binary (see README ) Polkadot JS Portal ( https://portal.chain.centrifuge.io ) Type definitions can be found here: https://gist.github.com/ansermino/0280b30594a9bc653ae288ccca46dc55 cb-sol-cli (see README )","title":"Prerequisites"},{"location":"local/#starting-local-chains","text":"The easiest way to get started is to use the docker-compose file found here: https://gist.github.com/ansermino/f1571bb354d2007b26dce53d52dbca75 . This will start a geth instance and an instance of chainbridge-substrate-chain: docker-compose -f ./docker-compose-geth-substrate.yml up -V (Use -V to always start with new chains. These instructions depend on deterministic ethereum addresses, which are used as defaults implicitly by some of these commands. Avoid re-deploying the contracts without restarting both chains, or ensure to specify all the required parameters.)","title":"Starting Local Chains"},{"location":"local/#on-chain-setup-ethereum","text":"","title":"On-Chain Setup (Ethereum)"},{"location":"local/#deploy-contracts","text":"You can deploy the contracts to the geth chain like this: cb-sol-cli deploy --all --relayerThreshold 1 You should see an output such as this: ================================================================ Url: http://localhost:8545 Deployer: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Gas Limit: 8000000 Gas Price: 20000000 Deploy Cost: 0 .0 Options ======= Chain Id: 0 Threshold: 2 Relayers: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca,0x8e0a907331554AF72563Bd8D43051C2E64Be5d35,0x24962717f8fA5BA3b931bACaF9ac03924EB475a0,0x148FfB2074A9e59eD58142822b3eB3fcBffb0cd7,0x4CEEf6139f00F9F4535Ad19640Ff7A0137708485 Bridge Fee: 0 Expiry: 100 Contract Addresses ================================================================ Bridge: 0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B ---------------------------------------------------------------- Erc20 Handler: 0x3167776db165D8eA0f51790CA2bbf44Db5105ADF ---------------------------------------------------------------- Erc721 Handler: 0x3f709398808af36ADBA86ACC617FeB7F5B7B193E ---------------------------------------------------------------- Generic Handler: 0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07 ---------------------------------------------------------------- Erc20: 0x21605f71845f372A9ed84253d2D024B7B10999f4 ---------------------------------------------------------------- Erc721: 0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31 ---------------------------------------------------------------- Centrifuge Asset: 0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4 ================================================================","title":"Deploy Contracts"},{"location":"local/#register-resources","text":"# Register fungible resource ID with erc20 contract cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" --targetContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" # Register non-fungible resource ID with erc721 contract cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --targetContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" # Register generic resource ID cb-sol-cli bridge register-generic-resource --resourceId \"0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01\" --targetContract \"0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4\" --handler \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" --hash --deposit \"\" --execute \"store(bytes32)\"","title":"Register Resources"},{"location":"local/#specify-token-semantics","text":"To allow for a variety of use cases, the ethereum contracts support both the transfer and the mint/burn ERC methods. To simplify these examples we should use mint/burn : # Register the erc20 contract as mintable/burnable cb-sol-cli bridge set-burn --tokenContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" # Register the associated handler as a minter cb-sol-cli erc20 add-minter --minter \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" # Register the erc721 contract as mintable/burnable cb-sol-cli bridge set-burn --tokenContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" # Add the handler as a minter cb-sol-cli erc721 add-minter --minter \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\"","title":"Specify Token Semantics"},{"location":"local/#on-chain-setup-substrate","text":"","title":"On-Chain Setup (Substrate)"},{"location":"local/#add-relayer","text":"We need to register the account of the relayer on substrate (cb-sol-cli deploys contracts with the 5 test keys preloaded). Select the Sudo tab in the PolkadotJS UI. Choose the addRelayer method of chainBridge , and select Alice as the relayer.","title":"Add Relayer"},{"location":"local/#register-resources_1","text":"Select the Sudo tab and call chainBridge.setResourceId for each of the transfer types you wish to use: Fungible (Native asset): Id: 0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00 Method: 0x4578616d706c652e7472616e73666572 (utf-8 encoding of \"Example.transfer\") NonFungible(ERC721): Id: 0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501 Method: 0x4578616d706c652e6d696e745f657263373231 (utf-8 encoding of \"Example.mint_erc721\") Generic (Hash Transfer): Id: 0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01 Method: 0x4578616d706c652e72656d61726b (utf-8 encoding of \"Example.remark\")","title":"Register Resources"},{"location":"local/#whitelist-chains","text":"Using the Sudo tab, call chainBridge.whitelistChain , specifying 0 for out ethereum chain ID.","title":"Whitelist Chains"},{"location":"local/#running-a-relayer","text":"Here is an example config file for a single relayer using the contracts we deployed. { \"chains\" : [ { \"name\" : \"eth\" , \"type\" : \"ethereum\" , \"id\" : \"0\" , \"endpoint\" : \"ws://localhost:8545\" , \"from\" : \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\" , \"opts\" : { \"bridge\" : \"0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B\" , \"erc20Handler\" : \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" , \"erc721Handler\" : \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" , \"genericHandler\" : \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" , \"gasLimit\" : \"1000000\" , \"maxGasPrice\" : \"20000000\" } }, { \"name\" : \"sub\" , \"type\" : \"substrate\" , \"id\" : \"1\" , \"endpoint\" : \"ws://localhost:9944\" , \"from\" : \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\" , \"opts\" : {} } ] } You can then start a relayer using the default \"Alice\" key: chainbridge --config config.json --testkey alice --latest","title":"Running A Relayer"},{"location":"local/#fungible-transfers","text":"","title":"Fungible Transfers"},{"location":"local/#substrate-native-token-erc-20","text":"In the substrate UI select the Extrinsics tab, and call example.transferNative with these parameters: Amount: 1000 (select Pico for units) Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Dest Id: 0 You can query the recipients balance on ethereum with this: cb-sol-cli erc20 balance --address \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\"","title":"Substrate Native Token \u21d2 ERC 20"},{"location":"local/#erc20-substrate-native-token","text":"If necessary, you can mint some tokens: cb-sol-cli erc20 mint --amount 1000 Before initiating the transfer we have to approve the bridge to take ownership of the tokens: cb-sol-cli erc20 approve --amount 1000 --recipient \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" To initiate a transfer on the ethereum chain use this command (Note: there will be a 10 block delay before the relayer will process the transfer): cb-sol-cli erc20 deposit --amount 1000 --dest 1 --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\" --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\"","title":"ERC20 \u21d2 Substrate Native Token"},{"location":"local/#non-fungible-transfers","text":"","title":"Non-Fungible Transfers"},{"location":"local/#substrate-nft-erc721","text":"First, you'll probably need to mint a token. Select the Sudo tab and call erc721.mint with parameters such as these: Owner: Alice TokenId: 1 Metadata: \"\" Now the owner of the token can initiate a transfer by calling example.transferErc721 : Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca TokenId: 1 DestId: 0 You can query ownership of tokens on ethereum with this: cb-sol-cli erc721 owner --id 0x1","title":"Substrate NFT \u21d2 ERC721"},{"location":"local/#erc721-substrate-nft","text":"If necessary, you can mint an erc721 token like this: cb-sol-cli erc721 mint --id 0x99 Before initiating the transfer, we must approve the bridge to take ownership of the tokens: cb-sol-cli erc721 approve --id 0x99 --recipient \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" Now we can initiate the transfer: cb-sol-cli erc721 deposit --id 0x99 --dest 1 --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\"","title":"ERC721 \u21d2 Substrate NFT"},{"location":"local/#generic-data-transfer","text":"To demonstrate a possible use of the generic data transfer, we have a hash registry on ethereum. We also have a method on the example substrate chain to emit a hash inside an event, which we can trigger from ethereum.","title":"Generic Data Transfer"},{"location":"local/#generic-data-substrate-eth","text":"For this example we will transfer a 32 byte hash to a registry on ethereum. Using the Extrinsics tab, call example.transferHash : Hash: 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730 Dest ID: 0 You can verify the transfer with this command: cb-sol-cli cent getHash --hash 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730","title":"Generic Data Substrate \u21d2 Eth"},{"location":"test/","text":"Testing \u00b6 Unit tests require an ethereum node running on localhost:8545 and a substrate node running on localhost:9944 . E2E tests require an additional ethereum node on localhost:8546 . A docker-compose file is provided to run two Geth nodes and a chainbridge-substrate-chain node in isolated environments: $ docker-compose -f ./docker-compose-e2e.yml up See chainbridge-solidity and chainbridge-substrate-chain for more information on testing facilities. All Go tests can be run with: $ make test Go tests specifically for ethereum, substrate and E2E can be run with $ make test-eth $ make test-sub $ make test-e2e","title":"Testing"},{"location":"test/#testing","text":"Unit tests require an ethereum node running on localhost:8545 and a substrate node running on localhost:9944 . E2E tests require an additional ethereum node on localhost:8546 . A docker-compose file is provided to run two Geth nodes and a chainbridge-substrate-chain node in isolated environments: $ docker-compose -f ./docker-compose-e2e.yml up See chainbridge-solidity and chainbridge-substrate-chain for more information on testing facilities. All Go tests can be run with: $ make test Go tests specifically for ethereum, substrate and E2E can be run with $ make test-eth $ make test-sub $ make test-e2e","title":"Testing"},{"location":"chains/ethereum/","text":"Ethereum Implementation Specification \u00b6 The solidity implementation of ChainBridge should consist of a central Bridge contract, and will delegate specific functionality to handlers . Fungible and non-fungible compatibility should be focused on ERC20 and ERC721 tokens. Transfer Flow \u00b6 As Source Chain \u00b6 Some user calls the deposit function on the bridge contract. A depositRecord is created on the bridge and a call is delgated to a handler contract specified by the provided resourceID . The specified handler's deposit function validates the parameters provided by the user. If successful, a depositRecord is created on the handler. If the call delegated to the handler is succesful, the bridge emits a Deposit event. Relayers parse the Deposit event and retrieve the associated DepositRecord from the handler to construct a message. As Destination Chain \u00b6 A Relayer calls voteProposal on the bridge contract. If a proposal corresponding with the parameters passed in does not exist, it is created and the Relayer's vote is recorded. If the proposal already exists, the Relayer's vote is simply recorded. Once we have met some vote threshold for a proposal , the bridge emits a ProposalFinalized event. Upon seeing a ProposalFinalized event, Relayers call the executeDeposit function on the bridge. executeDeposit delegates a call to a handler contract specified by the associated resourceID . The specified handler's executeDeposit function validates the paramters provided and makes a call to some contract to complete the transfer. Bridge Contract \u00b6 Users and relayers will interact with the Bridge contract. This delegates calls to the handler contracts for deposits and executing proposals. function deposit ( uint8 destinationChainID, bytes32 resourceID, bytes calldata data ) Handler Contracts \u00b6 To provide modularity and break out the necessary contract logic, the implementation uses a notion of handlers. A handler is defined for ERC20, ERC721 and generic transfers. These map directly to the Fungible, Non-Fungible, and generic transfer types. A handler must fulfill two interfaces: // Will be called by the bridge contract to initiate a transfer function deposit(uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) // TODO: This would be more aptly named executeProposal // Called by the bridge contract to complete a transfer function executeDeposit(bytes calldata data) The calldata field is the parameters required for the handler. The exact serialization is defined for each handler. ERC20 & ERC721 Handlers \u00b6 These handlers share a lot of similarities. These handlers are responsible for transferring ERC assets. They should provide the ability for the bridge to take ownership of tokens and release tokens to execute transfers. Different configurations may require different interface interactions. For example, it may make sense to mint and burn a token that is originally from another chain. If supply needs to be controlled, transferring tokens in and out of a reserve may be desired instead. To support either case handlers should associate each resource ID/token contract with one of these: transferFrom() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call transferFrom() as part of the transfer initiation. For the inverse, the handler will call transfer() to release tokens from the handlers ownership. mint() / burn() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call burnFrom() as part of the transfer initiation. For the inverse, the handler will call mint() to release tokens to the recipient (and must have privileges to do so). ERC20 Handler \u00b6 Calldata for deposit() \u00b6 Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END Calldata for executeDeposit() \u00b6 Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - END ERC721 Handler \u00b6 Metadata \u00b6 The tokenURI should be used as the metadata field if the contract supports the Metadata extension (interface ID 0x5b5e139f ). Calldata for deposit() \u00b6 Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END Calldata for executeDeposit() \u00b6 Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - 95 Metadata Length uint256 96 - 127 Metadata bytes 128 - END Generic Handler \u00b6 As well as associating a resource ID to a contract address, the generic handler should allow specific functions on those contracts to be used. To allow for this we must: Use function selectors to identify functions. Require functions that accept bytes as a the only parameter OR require the data already be ABI encoded for the function Deposit \u00b6 In a generic context, a deposit is simply the initiation of a transfer of a piece of data. To (optionally) allow this data to be validated for transfer the deposit mechanism should pass the data to a specified function and proceed with the transfer if the call succeeds (ie. does not revert). A function selector of 0x00 should skip the deposit function call. Execute \u00b6 An execution function must be specified. When executeDeposit() is called on the handler it should pass the metadata field to the specified function. Calldata for deposit() \u00b6 Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END Calldata for execute() \u00b6 Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END Administration \u00b6 The contracts should be controlled by an admin account. This should control the relayer set, manage the resource IDs, and specify the handlers. It should also be able to pause and unpause transfers at any times. Substrate Implementation Specification \u00b6 Events Inter-Pallet Communication Bridge Account ID & Origin Check Executing Calls The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a Proposal type equivalent to a dispatchable call to theoretically allow for any call to be made. pub trait Trait : system :: Trait { type Proposal : Parameter + Dispatchable < Origin = Self :: Origin > + EncodeLike + GetDispatchInfo ; } Events \u00b6 To easily distinguish different transfer types we should define three event types: /// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata) FungibleTransfer ( ChainId , DepositNonce , ResourceId , U256 , Vec < u8 > ) /// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata) NonFungibleTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > , Vec < u8 > , Vec < u8 > ) /// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata) GenericTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > ) These can be observed by relayers and should provide enough context to construct transfer messages. Inter-Pallet Communication \u00b6 The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers: pub fn transfer_fungible ( dest_id : ChainId , resource_id : ResourceId , to : Vec < u8 > , amount : U256 ,) pub fn transfer_nonfungible ( dest_id : ChainId , resource_id : ResourceId , token_id : Vec < u8 > , to : Vec < u8 > , metadata : Vec < u8 > ) pub fn transfer_generic ( dest_id : ChainId , resource_id : ResourceId , metadata : Vec < u8 > ) These should result in the associated event being emitted with the correct parameters. Bridge Account ID & Origin Check \u00b6 To allow the bridge pallet to take ownership of tokens a ModuleId should be used to derive an AccountId . A bridge origin check (implementing EnsureOrigin ) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal. Executing Calls \u00b6 The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin. Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls: - Fungible: Call(origin, recipient: AccountId, amount: u128) - Non-Fungible: Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec<u8>) - Generic: Call(origin, data: Vec<u8>) Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls","title":"Ethereum"},{"location":"chains/ethereum/#ethereum-implementation-specification","text":"The solidity implementation of ChainBridge should consist of a central Bridge contract, and will delegate specific functionality to handlers . Fungible and non-fungible compatibility should be focused on ERC20 and ERC721 tokens.","title":"Ethereum Implementation Specification"},{"location":"chains/ethereum/#transfer-flow","text":"","title":"Transfer Flow"},{"location":"chains/ethereum/#as-source-chain","text":"Some user calls the deposit function on the bridge contract. A depositRecord is created on the bridge and a call is delgated to a handler contract specified by the provided resourceID . The specified handler's deposit function validates the parameters provided by the user. If successful, a depositRecord is created on the handler. If the call delegated to the handler is succesful, the bridge emits a Deposit event. Relayers parse the Deposit event and retrieve the associated DepositRecord from the handler to construct a message.","title":"As Source Chain"},{"location":"chains/ethereum/#as-destination-chain","text":"A Relayer calls voteProposal on the bridge contract. If a proposal corresponding with the parameters passed in does not exist, it is created and the Relayer's vote is recorded. If the proposal already exists, the Relayer's vote is simply recorded. Once we have met some vote threshold for a proposal , the bridge emits a ProposalFinalized event. Upon seeing a ProposalFinalized event, Relayers call the executeDeposit function on the bridge. executeDeposit delegates a call to a handler contract specified by the associated resourceID . The specified handler's executeDeposit function validates the paramters provided and makes a call to some contract to complete the transfer.","title":"As Destination Chain"},{"location":"chains/ethereum/#bridge-contract","text":"Users and relayers will interact with the Bridge contract. This delegates calls to the handler contracts for deposits and executing proposals. function deposit ( uint8 destinationChainID, bytes32 resourceID, bytes calldata data )","title":"Bridge Contract"},{"location":"chains/ethereum/#handler-contracts","text":"To provide modularity and break out the necessary contract logic, the implementation uses a notion of handlers. A handler is defined for ERC20, ERC721 and generic transfers. These map directly to the Fungible, Non-Fungible, and generic transfer types. A handler must fulfill two interfaces: // Will be called by the bridge contract to initiate a transfer function deposit(uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) // TODO: This would be more aptly named executeProposal // Called by the bridge contract to complete a transfer function executeDeposit(bytes calldata data) The calldata field is the parameters required for the handler. The exact serialization is defined for each handler.","title":"Handler Contracts"},{"location":"chains/ethereum/#erc20-erc721-handlers","text":"These handlers share a lot of similarities. These handlers are responsible for transferring ERC assets. They should provide the ability for the bridge to take ownership of tokens and release tokens to execute transfers. Different configurations may require different interface interactions. For example, it may make sense to mint and burn a token that is originally from another chain. If supply needs to be controlled, transferring tokens in and out of a reserve may be desired instead. To support either case handlers should associate each resource ID/token contract with one of these: transferFrom() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call transferFrom() as part of the transfer initiation. For the inverse, the handler will call transfer() to release tokens from the handlers ownership. mint() / burn() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call burnFrom() as part of the transfer initiation. For the inverse, the handler will call mint() to release tokens to the recipient (and must have privileges to do so).","title":"ERC20 &amp; ERC721 Handlers"},{"location":"chains/ethereum/#erc20-handler","text":"","title":"ERC20 Handler"},{"location":"chains/ethereum/#calldata-for-deposit","text":"Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END","title":"Calldata for deposit()"},{"location":"chains/ethereum/#calldata-for-executedeposit","text":"Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - END","title":"Calldata for executeDeposit()"},{"location":"chains/ethereum/#erc721-handler","text":"","title":"ERC721 Handler"},{"location":"chains/ethereum/#metadata","text":"The tokenURI should be used as the metadata field if the contract supports the Metadata extension (interface ID 0x5b5e139f ).","title":"Metadata"},{"location":"chains/ethereum/#calldata-for-deposit_1","text":"Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END","title":"Calldata for deposit()"},{"location":"chains/ethereum/#calldata-for-executedeposit_1","text":"Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - 95 Metadata Length uint256 96 - 127 Metadata bytes 128 - END","title":"Calldata for executeDeposit()"},{"location":"chains/ethereum/#generic-handler","text":"As well as associating a resource ID to a contract address, the generic handler should allow specific functions on those contracts to be used. To allow for this we must: Use function selectors to identify functions. Require functions that accept bytes as a the only parameter OR require the data already be ABI encoded for the function","title":"Generic Handler"},{"location":"chains/ethereum/#deposit","text":"In a generic context, a deposit is simply the initiation of a transfer of a piece of data. To (optionally) allow this data to be validated for transfer the deposit mechanism should pass the data to a specified function and proceed with the transfer if the call succeeds (ie. does not revert). A function selector of 0x00 should skip the deposit function call.","title":"Deposit"},{"location":"chains/ethereum/#execute","text":"An execution function must be specified. When executeDeposit() is called on the handler it should pass the metadata field to the specified function.","title":"Execute"},{"location":"chains/ethereum/#calldata-for-deposit_2","text":"Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END","title":"Calldata for deposit()"},{"location":"chains/ethereum/#calldata-for-execute","text":"Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END","title":"Calldata for execute()"},{"location":"chains/ethereum/#administration","text":"The contracts should be controlled by an admin account. This should control the relayer set, manage the resource IDs, and specify the handlers. It should also be able to pause and unpause transfers at any times.","title":"Administration"},{"location":"chains/ethereum/#substrate-implementation-specification","text":"Events Inter-Pallet Communication Bridge Account ID & Origin Check Executing Calls The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a Proposal type equivalent to a dispatchable call to theoretically allow for any call to be made. pub trait Trait : system :: Trait { type Proposal : Parameter + Dispatchable < Origin = Self :: Origin > + EncodeLike + GetDispatchInfo ; }","title":"Substrate Implementation Specification"},{"location":"chains/ethereum/#events","text":"To easily distinguish different transfer types we should define three event types: /// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata) FungibleTransfer ( ChainId , DepositNonce , ResourceId , U256 , Vec < u8 > ) /// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata) NonFungibleTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > , Vec < u8 > , Vec < u8 > ) /// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata) GenericTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > ) These can be observed by relayers and should provide enough context to construct transfer messages.","title":"Events"},{"location":"chains/ethereum/#inter-pallet-communication","text":"The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers: pub fn transfer_fungible ( dest_id : ChainId , resource_id : ResourceId , to : Vec < u8 > , amount : U256 ,) pub fn transfer_nonfungible ( dest_id : ChainId , resource_id : ResourceId , token_id : Vec < u8 > , to : Vec < u8 > , metadata : Vec < u8 > ) pub fn transfer_generic ( dest_id : ChainId , resource_id : ResourceId , metadata : Vec < u8 > ) These should result in the associated event being emitted with the correct parameters.","title":"Inter-Pallet Communication"},{"location":"chains/ethereum/#bridge-account-id-origin-check","text":"To allow the bridge pallet to take ownership of tokens a ModuleId should be used to derive an AccountId . A bridge origin check (implementing EnsureOrigin ) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal.","title":"Bridge Account ID &amp; Origin Check"},{"location":"chains/ethereum/#executing-calls","text":"The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin. Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls: - Fungible: Call(origin, recipient: AccountId, amount: u128) - Non-Fungible: Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec<u8>) - Generic: Call(origin, data: Vec<u8>) Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls","title":"Executing Calls"},{"location":"chains/substrate/","text":"Substrate Implementation Specification \u00b6 The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a Proposal type equivalent to a dispatchable call to theoretically allow for any call to be made. pub trait Trait : system :: Trait { type Proposal : Parameter + Dispatchable < Origin = Self :: Origin > + EncodeLike + GetDispatchInfo ; } Events \u00b6 To easily distinguish different transfer types we should define three event types: /// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata) FungibleTransfer ( ChainId , DepositNonce , ResourceId , U256 , Vec < u8 > ) /// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata) NonFungibleTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > , Vec < u8 > , Vec < u8 > ) /// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata) GenericTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > ) These can be observed by relayers and should provide enough context to construct transfer messages. Inter-Pallet Communication \u00b6 The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers: pub fn transfer_fungible ( dest_id : ChainId , resource_id : ResourceId , to : Vec < u8 > , amount : U256 ,) pub fn transfer_nonfungible ( dest_id : ChainId , resource_id : ResourceId , token_id : Vec < u8 > , to : Vec < u8 > , metadata : Vec < u8 > ) pub fn transfer_generic ( dest_id : ChainId , resource_id : ResourceId , metadata : Vec < u8 > ) These should result in the associated event being emitted with the correct parameters. Bridge Account ID & Origin Check \u00b6 To allow the bridge pallet to take ownership of tokens a ModuleId should be used to derive an AccountId . A bridge origin check (implementing EnsureOrigin ) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal. Executing Calls \u00b6 The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin. Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls: - Fungible: Call(origin, recipient: AccountId, amount: u128) - Non-Fungible: Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec<u8>) - Generic: Call(origin, data: Vec<u8>) Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls","title":"Substrate"},{"location":"chains/substrate/#substrate-implementation-specification","text":"The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a Proposal type equivalent to a dispatchable call to theoretically allow for any call to be made. pub trait Trait : system :: Trait { type Proposal : Parameter + Dispatchable < Origin = Self :: Origin > + EncodeLike + GetDispatchInfo ; }","title":"Substrate Implementation Specification"},{"location":"chains/substrate/#events","text":"To easily distinguish different transfer types we should define three event types: /// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata) FungibleTransfer ( ChainId , DepositNonce , ResourceId , U256 , Vec < u8 > ) /// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata) NonFungibleTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > , Vec < u8 > , Vec < u8 > ) /// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata) GenericTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > ) These can be observed by relayers and should provide enough context to construct transfer messages.","title":"Events"},{"location":"chains/substrate/#inter-pallet-communication","text":"The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers: pub fn transfer_fungible ( dest_id : ChainId , resource_id : ResourceId , to : Vec < u8 > , amount : U256 ,) pub fn transfer_nonfungible ( dest_id : ChainId , resource_id : ResourceId , token_id : Vec < u8 > , to : Vec < u8 > , metadata : Vec < u8 > ) pub fn transfer_generic ( dest_id : ChainId , resource_id : ResourceId , metadata : Vec < u8 > ) These should result in the associated event being emitted with the correct parameters.","title":"Inter-Pallet Communication"},{"location":"chains/substrate/#bridge-account-id-origin-check","text":"To allow the bridge pallet to take ownership of tokens a ModuleId should be used to derive an AccountId . A bridge origin check (implementing EnsureOrigin ) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal.","title":"Bridge Account ID &amp; Origin Check"},{"location":"chains/substrate/#executing-calls","text":"The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin. Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls: - Fungible: Call(origin, recipient: AccountId, amount: u128) - Non-Fungible: Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec<u8>) - Generic: Call(origin, data: Vec<u8>) Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls","title":"Executing Calls"}]}